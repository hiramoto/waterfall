<!DOCTYPE html>
<html>
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta charset="UTF-8">
        <title>Waterfall</title>
        <style>
            body {
              background-color: #333333;
            }
            
            button {
              background-color: #555555;
              color: #ffffff;
              border: none;
              cursor: pointer;
              padding: 10px 20px;
              transition: background-color 0.3s;
            }
            
            button:hover {
              background-color: #777777;
            }
        </style>
    </head>
    
    <body>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.30/Tone.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/p5@1.3.1/lib/p5.js"></script>
        <script type="text/javascript">
            // --- Audio: layered noise for realistic waterfall ---
            // Main water flow: pink noise through bandpass
            let noiseMain = new Tone.Noise("pink");
            let filterMain = new Tone.Filter({
                type: "bandpass",
                frequency: 800,
                Q: 0.5
            }).connect(Tone.Master);
            noiseMain.connect(filterMain);
            noiseMain.volume.value = -8;

            // Low rumble: brown noise through lowpass
            let noiseLow = new Tone.Noise("brown");
            let filterLow = new Tone.Filter({
                type: "lowpass",
                frequency: 200,
                Q: 0.8
            }).connect(Tone.Master);
            noiseLow.connect(filterLow);
            noiseLow.volume.value = -12;

            // High splash: white noise through highpass with auto-filter for shimmer
            let noiseHigh = new Tone.Noise("white");
            let filterHigh = new Tone.Filter({
                type: "highpass",
                frequency: 3000,
                Q: 0.3
            });
            let autoFilter = new Tone.AutoFilter({
                frequency: "4n",
                min: 2000,
                max: 6000,
                depth: 0.4
            }).connect(Tone.Master);
            noiseHigh.connect(filterHigh);
            filterHigh.connect(autoFilter);
            noiseHigh.volume.value = -22;

            function startAudio() {
                Tone.start();
                noiseMain.start();
                noiseLow.start();
                noiseHigh.start();
                autoFilter.start();
            }
            function stopAudio() {
                noiseMain.stop();
                noiseLow.stop();
                noiseHigh.stop();
                autoFilter.stop();
            }

            // --- Optimized particle system: TypedArray SoA + free-list ---
            const MAX_PARTICLES = 2000;
            const PARTICLES_PER_FRAME = 15;
            let canvasW, canvasH, fallHeight, originX, originY;

            // Struct-of-Arrays: contiguous TypedArrays (~64KB total vs ~600KB+ with JS objects)
            const P_PX      = new Float32Array(MAX_PARTICLES);
            const P_PY      = new Float32Array(MAX_PARTICLES);
            const P_VX      = new Float32Array(MAX_PARTICLES);
            const P_VY      = new Float32Array(MAX_PARTICLES);
            const P_LIFE    = new Float32Array(MAX_PARTICLES);
            const P_MAXLIFE = new Float32Array(MAX_PARTICLES);
            const P_SIZE    = new Float32Array(MAX_PARTICLES);
            const P_TYPE    = new Uint8Array(MAX_PARTICLES);
            const P_ALIVE   = new Uint8Array(MAX_PARTICLES);

            // Free-list stack for O(1) particle allocation (was O(n) linear search)
            const freeStack = new Uint16Array(MAX_PARTICLES);
            let freeTop = MAX_PARTICLES;
            for (let i = 0; i < MAX_PARTICLES; i++) freeStack[i] = i;

            function setup() {
                canvasW = innerWidth - 25;
                canvasH = innerHeight - 60;
                createCanvas(canvasW, canvasH);
                fallHeight = canvasH * 0.75;
                originX = width / 2;
                originY = 30;
                noStroke();
                noSmooth();
            }

            function draw() {
                background(20, 24, 36, 25);
                for (let i = 0; i < PARTICLES_PER_FRAME; i++) emitParticle();
                updateAndDrawParticles();
            }

            function emitParticle() {
                if (freeTop <= 0) return;
                let idx = freeStack[--freeTop];
                let tp = random() < 0.85 ? 0 : 1;
                P_TYPE[idx] = tp;
                P_ALIVE[idx] = 1;
                if (tp === 0) {
                    P_PX[idx] = originX + random(-30, 30);
                    P_PY[idx] = originY + random(-5, 5);
                    P_VX[idx] = random(-0.5, 0.5);
                    P_VY[idx] = random(1, 3);
                    P_MAXLIFE[idx] = random(180, 340);
                    P_SIZE[idx] = random(0.5, 1.5);
                } else {
                    P_PX[idx] = originX + random(-60, 60);
                    P_PY[idx] = fallHeight + random(-20, 30);
                    P_VX[idx] = random(-2, 2);
                    P_VY[idx] = random(-2, 0.5);
                    P_MAXLIFE[idx] = random(40, 100);
                    P_SIZE[idx] = random(1, 2.5);
                }
                P_LIFE[idx] = P_MAXLIFE[idx];
            }

            function updateAndDrawParticles() {
                for (let i = 0; i < MAX_PARTICLES; i++) {
                    if (!P_ALIVE[i]) continue;

                    // Update physics
                    if (P_TYPE[i] === 0) {
                        P_VY[i] += 0.08;
                        P_VX[i] += random(-0.02, 0.02);
                        if (P_PY[i] > fallHeight) {
                            P_LIFE[i] -= 8;
                            P_VX[i] *= 1.05;
                            P_VY[i] *= -0.2;
                        }
                    } else {
                        P_VY[i] -= 0.01;
                        P_VX[i] += random(-0.05, 0.05);
                    }
                    P_PX[i] += P_VX[i];
                    P_PY[i] += P_VY[i];
                    P_LIFE[i] -= 1;

                    if (P_LIFE[i] <= 0) {
                        P_ALIVE[i] = 0;
                        freeStack[freeTop++] = i;
                        continue;
                    }

                    // Draw
                    let t = P_LIFE[i] / P_MAXLIFE[i];
                    if (P_TYPE[i] === 0) {
                        let alpha = t * 180;
                        let b = 200 + (1 - t) * 55;
                        fill(180, 210, b, alpha);
                        rect(P_PX[i], P_PY[i], P_SIZE[i], P_SIZE[i] * 1.5);
                    } else {
                        let alpha = t * 60;
                        fill(220, 230, 255, alpha);
                        ellipse(P_PX[i], P_PY[i], P_SIZE[i], P_SIZE[i]);
                    }
                }
            }

        </script>
        <div style="display:flex;justify-content: center;">
            <button onclick="startAudio();">start</button>
            <button onclick="stopAudio();">pause</button>
        </div>
    </body>
</html>